> [!success] Preflight Request의 등장 배경 
> - Preflight Request(이하 사전 요청)은 CORS가 도입됨에 따라 고안되었다. 
> - <u>CORS 개발자들의 주된 관심사는 이미 SOP가 적용된 웹 환경에서 동작하는 수많은 서비스들을 고장내지 않고 CORS를 정착시키는 것</u>에 있었다.
### 옛날에는...
- 사전 요청이 등장하기 전에 작성된 옛날 서버 중 '일부'는 다음과 같은 전제 하에 개발되었다:
	- 웹 브라우저에 의한 교차 출처 삭제 요청(=HTTP 메소드가 `DELETE`)는 애초에 불가능하다.
	- `X-Api-Key`와 같은 형태의 헤더는 애초에 불가능하다.
- 실제로도 그 당시 웹 스펙 상 이는 틀림이 없었으나, 웹이 발달하고 교차 출처 리소스 공유가 가능해짐에 따라 이러한 전제들은 모두 깨지게 되었다.
#### 참고 - Simple Request의 등장 배경
- 추가적으로, `Simple Request`가 제시하는 엄격한 조건들은 실제로는 '아주 옛날부터 모든 서버가 처리 가능하던' 스펙을 의미하고 있다.
	- 즉, 주로 `<form>` 등의 태그를 활용하던 **아주 원시적인 서버들조차 모두 처리 가능한 요청 스펙을 `Simple Request`라고 명명한 것**이다.
- 때문에 아주 오래된 서버들조차 교차 출처 리소스에 대한 `Simple Request`에 대비하고 있을 것이므로, 이 경우에는 별도의 조치 없이 본 요청만으로 CORS를 처리하도록 개발해도 무방했다.
---
### CORS의 등장
#### CORS 개발진의 고민
- 문제는, 상술한 전제 하에 개발된 서버들은 종종 '웹 브라우저에 의해 저러한 요청들이 들어오는 것은 애초에 불가능하므로, 이러한 요청들은 웹 브라우저가 아닌 신뢰할 수 있는 주체(예: 다른 서버)에 의해 요청되었을 것'이라는 **잘못된(그 당시에는 맞았을지 몰라도) 가정 하에 잠재적인 보안 위협을 내포하곤 했다는 점**이다.
	- 때문에 아무런 추가적인 조치 없이 `Simple Request` 만으로 교차 출처 리소스 삭제 요청 등을 허용할 경우, 이 서버가 정말로 CORS에 대비하고 있는지 / 또는 순진하게 이러한 유형의 모든 요청이 신뢰할 수 있는 주체에 의해 발생되었다고 믿는지 구분할 수 없는 문제가 있었다.
- 이에 CORS 개발자들은 '정말로 CORS를 알고 있는 서버'와 '잘못된 가정 하에 모든 요청을 받아들이는 서버'를 구분할 필요가 있었으며, 결과적으로 사전 요청 개념을 도입하게 되었다.
	- 예를 들어, 사전 요청에 정상적으로 응답하는 서버는 '정말로 CORS를 알고 있는 서버'일 것이며, <u>그렇지 못한 서버는 웹 브라우저가 전송한 사전 요청 차원에서 즉각 처리될 것이므로 안전</u>하다.
---
- [stackoverflow](https://stackoverflow.com/questions/39725955/why-is-there-no-preflght-in-cors-for-post-requests-with-standard-content-type) 