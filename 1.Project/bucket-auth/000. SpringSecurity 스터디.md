### spring security 의존성
- **security 의존성을 설정할 경우, 해당 서버는 모든 경로에 대해 인증이 필요한 서버로 기능**하게 된다.
- 아래와 같은 형태로 시큐리티 전용 설정 파일을 생성할 경우, 명시된 스프링 시큐리티 필터가 스프링 필터 체인에 등록된다.
```kotlin
@Configuration  
@EnableWebSecurity // 스프링 시큐리티 필터가 스프링 필터체인에 등록됨  
class SecurityConfig {  
    @Bean  
    fun filterChain(http: HttpSecurity): SecurityFilterChain = http.run {  
        csrf { it.disable() }  
        authorizeHttpRequests {  
            it                // 로그인 사용자만 허용  
                .requestMatchers("/user/**").authenticated()  
                // 로그인 사용자 + admin + manager 권한만 허용  
                .requestMatchers("/manager/**").access(  
                    WebExpressionAuthorizationManager("hasRole('ROLE_ADMIN') or hasRole('ROLE_MANAGER')")  
                )  
                // 로그인 사용자 + admin 권한만 허용  
                .requestMatchers("/admin/**").access(  
                    WebExpressionAuthorizationManager("hasRole('ROLE_ADMIN')")  
                )  
                // 그 외 모든 요청은 허용  
                .anyRequest().permitAll()  
        }  
  
        // 로그인 페이지  
        formLogin { it.loginPage("/login") }  
  
        build()  
    }  
}
```

### 컨트롤러 메소드에 대한 인증 적용
임의의 컨트롤러 메소드에만 어떠한 권한을 가진 사용자에 대해 접근을 허용하고자 하는 경우, 아래와 같이 간단하게 작성할 수 있다.
```kotlin
@Controller  
class IndexController {  
    @Secured("ROLE_ADMIN") // 이렇게!
    @GetMapping("/info")  
    @ResponseBody  
    fun info(): String {  
        return "개인정보"  
    }  
    
	@PreAuthorize("hasRole('ROLE_MANAGER') or hasRole('ROLE_ADMIN')") // 또는 이렇게!
	@GetMapping("/data")  
	@ResponseBody  
	fun data(): String {  
	    return "데이터 정보"  
	}
}
```
상술한 두 방식은 각각 대응되는 설정이 있으며, 이는 아래와 같다.
```kotlin
@Configuration  
@EnableWebSecurity // 스프링 시큐리티 필터가 스프링 필터체인에 등록됨  
@EnableMethodSecurity(securedEnabled = true, prePostEnabled = true) // 1. secured 어노테이션을 활성화한다! 2. preAuthorize 어노테이션을 활성화한다!  
class SecurityConfig {  
	// ...생략
}
```

유사한 개념으로 `@PostAuthorize`도 있으나 이는 잘 사용되지 않으며, 일반적으로는 `@PreAuthorize`보다 `@Secured`가 자주 사용된다. **이러한 방식은 임의의 컨트롤러 메소드에만 인증을 적용하고자 하는 경우에 활용하며, 그렇지 않은 경우에는 `authorizeHttpRequests`를 활용하는 글로벌 설정을 적용하는 것이 권장**된다.