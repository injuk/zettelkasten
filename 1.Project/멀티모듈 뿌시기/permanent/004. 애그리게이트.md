### 애그리게이트란?
> 데이터를 변경하는 변경의 단위로서 기능하는 객체의 집합

객체지향 프로그래밍에서는 여러 객체가 모여 하나의 의미를 가질 수 있으며, 이 경우 객체 집합 내부적으로는 어떠한 불변 조건이 작용할 필요가 있다.
애그리게이트는 외부로 공개한 **단일 객체를 기반으로 모든 내부 조작을 처리하므로, 외부로부터 애그리게이트가 사용되는 과정에서도 내부적인 불변 조건을 유지하도록 지원**한다.

때문에 애그리게이트는 애그리게이트에 포함되는 객체를 결정하는 **경계**와, 애그리게이트에 포함된 객체 중 대표적인 하나의 객체인 **루트 엔티티**를 포함한다. 경계 외부로부터의 내부로 향하는 모든 호출은 루트 엔티티를 거치게 되며, 이 과정에서 **루트 이외의 모든 객체가 외부에 노출되지 않아 불변 조건이 유지**된다.

> [!WARNING] 애그리게이트 다이어그램?
> 애그리게이트를 다이어그램으로 나타낼 경우, 경계와 경계 내부에 포함된 모델을 명시하게 된다.
> 그러나 코드와 다이어그램은 정확히 1:1로 표현되어야 하는 것이 아니므로, 다이어그램은 반드시 코드와 일치할 필요는 없다.

#### 애그리거트의 경계를 지정하기
> 애그리게이트의 경계를 정하는 원칙 중 대표적인 것은 변경의 단위를 고려하는 것이다.

애그리게이트가 자신의 경계를 넘어 다른 애그리게이트를 조작하게 될 경우, 유사한 코드가 소프트웨어의 여기 저기에 퍼져 유지보수성을 크게 떨어트릴 수 있다. 때문에 애그리게이트에 대한 변경은 반드시 해당 애그리게이트에 위임하고, **영속화 역시 애그리게이트 단위로 처리하는 것이 바람직하다. 물론, 이를 위해서는 리포지토리를 애그리게이트마다 하나씩 작성**하게 된다.

#### 애그리게이트 간의 협업
임의의 애그리게이트 A 객체가 애그리게이트 B의 객체와 협업할 경우, 애그리게이트 A 객체 안에 애그리게이트 B의 객체를 컬렉션 형태로 지정하는 식으로 코드를 작성할 수 있다.
그러나 이러한 방식은 애그리게이트 A 객체가 애그리게이트 B 객체에 대한 조작을 시도하는 상황을 제한할 수 없으므로 바람직한 방식이 아니다. 
이러한 이유에서 **각 객체는 협업 대상 객체 자체가 아닌 식별자 정보만을 갖도록 코드를 작성**할 수 있으며, 이 경우 메모리를 절약하면서도 협업 대상을 직접적으로 조작할 수 없으므로 코드의 안전성 역시 높아질 수 있다.